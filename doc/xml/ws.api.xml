<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book [
<!ENTITY % doc.mod SYSTEM "doc.mod" >
%doc.mod;
]>

<chapter version="5.0"
    xml:id="ws.api"
    xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:db="http://docbook.org/ns/docbook">

<title>C API</title>

<para>There are two APIs in the library: the WebSockts API and the Messaging
API. The WebSockets API is built solely upon WebSocket constructs: frames,
messages and connections, as you would expect. It intuitively follows the
concepts and structure laid out in the standard. The Messaging API is built on
top of the WebSockets API. While WebSockets provide a mechanism for real-time
bidirectional communication, it doesn't inherently offer things like you would
see in more heavyweight message protocols like AMQP. The Messaging API provides
a small step in that direction, but without the heft.</para>

<section id="ws.api.ws"><title>The Client API</title>

<para>There are three objects in the C API: connections given by the
<classname><cr f="websocket.h">vws_cnx</cr></classname>, <classname><cr
f="websocket.h">vws_frame</cr></classname> and <classname><cr
f="websocket.h">vws_msg</cr></classname>. The following example illustrates the
basic usage of the Client API:

<sourcecode href="ws.api.ws.example-1.cpp"/>

</para>

<section id="ws.api.ws.msg"><title>Messages and Frames</title>

<para>The <function><cr f="websocket.h">vws_frame_send_text</cr>()</function>,
<function><cr f="websocket.h">vws_frame_send_binary</cr>()</function> and
<function><cr f="websocket.h">vws_msg_recv</cr>()</function> work in terms of
frames. The first two send messages out as a single frame. The latter continues
to receive one or more frames back until it gets a frame with the FIN bit
set. It then concatenates the data from all frames to form a single
message.</para>

<para>While the API is geared around messages, you can deal in frames if you
need to. There are equivalent functions to send and receive frames:
<function><cr f="websocket.h">vws_frame_send_frame</cr>()</function>, <function>
<cr f="websocket.h">vws_frame_recv_frame</cr>()</function>, and <function> <cr
f="websocket.h">vws_frame_send_data</cr>()</function>. As frames arrive in they
are put on a receive queue. The <function><cr
f="websocket.h">vws_frame_recv</cr>()</function> function checks this queue. If
the queue is empty it performs a socket read until the queue has at least one
complete frame. If no frame arrives, it blocks until its set timeout and will
return NULL.</para>

<para>While frames are a concrete object in the standard, messages are
not. Messages are expressed in terms of frames. A message is one or more frames,
terminated by a frame with the <literal>FIN</literal> bit set. So I message can
be a single frame, which would have its <literal>FIN</literal> bit set. Or a
message can be multiple frames the last of which has the <literal>FIN</literal>
bet set. In the latter case, the first frame contains the content type (text,
binary, etc.). Subsequent frames in the chain or continuation frames (another
frame type). The last of these continuation frames will have the
<literal>FIN</literal> bit set, signifying the end of the message. The
<function><cr f="message.h">vrtql_msg_recv</cr>()</function> handles this logic
and continues to collect frames in the queue until there is at least one
complete message. It works almost identically <function><cr
f="websocket.h">vws_frame_recv</cr>()</function> but on a message level.</para>

</section>

<section id="ws.api.ws.errors"><title>Error Handling</title>

<para>

</para>

</section>

<section id="ws.api.ws.memory"><title>Memory Managements</title>

<para>

</para>

</section>

</section> <!-- ws.api.ws -->

<section id="ws.api.ws"><title>Message API</title>

<para>The message structure operates with a higher-level connection API which
works atop the native WebSocket API. It mainly provides a more structured
message format with built-in serialization. The message structure includes two
maps (hashtables of string key/value pairs) and a payload. One map, called
<varname>routing</varname>, is designed to hold routing information for
messaging applications. The other map, called <varname>headers</varname>, is for
application use. The payload can hold both text and binary data.</para>

<para>The associated connection API is really just two functions: <function><cr
f="message.h">vrtql_msg_send</cr>()</function> and <function><cr
f="message.h">vrtql_msg_recv</cr>()</function> calls which operate with these
messages. They send and receive the messages, automatically handling
serialization and deserialization on and off the wire.</para>

<para>Messages can be serialized in two formats: JSON and MessagePack. Both
formats can be sent over the same connection on a message-by-message basis. That
is, the connection is able to auto-detect each incoming message's format and
deserialize accordingly. Thus connections support mixed-content messages: JSON
and MessagePack.</para>

<para>The following is a basic example of using the high-level messaging API.

<sourcecode href="ws.api.msg.example-1.cpp"/>

</para>

</section> <!-- ws.api.msg -->

</chapter> <!-- ws.api -->
